package ru.vyarus.gradle.plugin.pom

import groovy.transform.CompileStatic
import groovy.transform.TypeCheckingMode
import org.gradle.api.GradleException
import org.gradle.api.Project

/**
 * Pom modifications configuration.
 * <p>
 * Example usage:
 * <pre>
 * <code>
 *     maven.pom {
 *         licenses {
 *              license {
 *                  name "The MIT License"
 *              }
 *         }
 *         developers {
 *             developer {
 *                 id "dev1"
 *                 name "Dev1 Name"
 *                 email "dev1@email.com"
 *             }
 *         }
 *     }
 * </code>
 * <pre>
 * Multiple declarations could be used.
 * <p>
 * If manual pom modification is required use:
 * <pre><code>
 *     maven.withPomXml {
 *         it.appendNode('description', 'A demonstration of maven POM customization')
 *     }
 * </code></pre>
 * withPomXml usage is equivalent to maven-publish plugin withXml closure, but without need to call
 * asNode() because node is already provided as parameter.
 *
 * @author Vyacheslav Rusakov
 * @since 27.05.2021
 */
@CompileStatic
class PomExtension {

    boolean forcedVersions
    boolean removedDependencyManagement
    boolean disabledScopesCorrection
    boolean disabledBomsReorder

    protected List<Closure> configs = []
    protected List<Closure> xmlModifiers = []

    // in multi-module project used for incorrect initialization detection when sub module's convention
    // wasn't initialized and root module's convention used (hard to track problems)
    private String projectPath

    PomExtension(Project project) {
        // project name where convention was registered
        projectPath = project.path
    }

    /**
     * Force dependency versions in the generated pom. Useful when gradle platforms used (by default generated pom
     * would rely on dependenciesManagement section).
     * <p>
     * Activated automatically for {@link #removeDependencyManagement()}.
     * <p>
     * Uses <a
     * href="https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:resolved_dependencies">
     * officially recommended way</a>.
     */
    void forceVersions() {
        forcedVersions = true
    }

    /**
     * Removes dependencyManagement section (generated by gradle for imported platforms). Also, forces dependency
     * versions ({@link #forceVersions()}) because without boms pom become invalid otherwise.
     * <p>
     * Option assumed to be used when gradle platforms used for dependency management, but it is not desired to
     * preserve platforms in the generated pom.
     * <p>
     * Compatible with spring dependency management plugin.
     */
    void removeDependencyManagement() {
        removedDependencyManagement = true
        forceVersions()
    }

    /**
     * Disables dependencies scopes fixes performed by the plugin. May be used to see the default gradle behaviour.
     * <p>
     * Optional and provided configurations dependencies would be generated with correct scopes in any case.
     */
    void disableScopesCorrection() {
        disabledScopesCorrection = true
    }

    /**
     * Gradle java-platform plugin always put used BOMs after other dependencies in the generated pom. Pom plugin fixes
     * this by putting all BOMs at the top (unifies with spring plugin behaviour).
     * <p>
     * Option disables BOMs reordering to see native gradle behaviour.
     */
    void disableBomsReorder() {
        disabledBomsReorder = true
    }

    /**
     * @param config user pom
     */
    void pom(Closure config) {
        validateTargetProjectCorrectness('pom', config)
        this.configs.add(config)
    }

    /**
     * Modification closure is called just after user pom merge. Pom xml passed to closure as {@link Node} parameter.
     * @param modifier manual pom modification closure
     */
    void withPomXml(Closure modifier) {
        validateTargetProjectCorrectness('withPomXml', modifier)
        this.xmlModifiers.add(modifier)
    }

    private void validateTargetProjectCorrectness(String type, Closure config) {
        String srcProject = findDeclarationProjectPath(config)
        // catching mistakes of root project configuration from module, but allowing subproject configuration
        // from upper project (last condition): project(':mod').pom { ... }
        if (srcProject && projectPath != srcProject && !projectPath.startsWith(srcProject)) {
            throw new GradleException("${type.capitalize()} closure declared in project '$srcProject'" +
                    " actually applied in '$projectPath' project (conventions are searched through project " +
                    "hierarchy). This means that $type closure was applied too early - before pom plugin created " +
                    'convention in sub module. ' +
                    "Most likely, this is because java plugin applied only in submodules section and this $type " +
                    "closure is in allprojects section. To fix this, wrap $type section with afterEvaluate " +
                    'to delay configuration until subproject convention would be created: \n' +
                    '\tafterEvaluate { \n' +
                    "\t\t$type { ... }\n" +
                    '\t}')
        }
    }

    /**
     * Closures are hierarchical. Need to only find reference to the top closure, representing project.
     *
     * @param config configuration closure (from build)
     * @return project path
     */
    @CompileStatic(TypeCheckingMode.SKIP)
    @SuppressWarnings('Instanceof')
    private String findDeclarationProjectPath(Closure config) {
        Object own = config.owner
        while (own instanceof Closure && !own.hasProperty('path')) {
            own = ((Closure) own).owner
        }
        // assuming this to be a project name
        return own?.path
    }
}
